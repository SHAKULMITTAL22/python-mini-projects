# ********RoostGPT********
"""
Test generated by RoostGPT for test python-test using AI Type DBRX and AI Model dbrx-instruct

ROOST_METHOD_HASH=month_days_1396fdc0ba
ROOST_METHOD_SIG_HASH=month_days_5dd3c5e333

Scenario 1: Verify the number of days in January for a non-leap year
TestName: test_month_days_january_non_leap_year
Description: Check that the function returns 31 days for January in a non-leap year.
Execution:
  Arrange: None
  Act: Call the month_days function with month=1 and leap_year=False
  Assert: Confirm that the function returns 31
Validation:
  This test is crucial for verifying the correct behavior of the function for a common month, ensuring that the function can handle months with 31 days and non-leap years.

Scenario 2: Verify the number of days in March for a leap year
TestName: test_month_days_march_leap_year
Description: Ensure that the function returns 31 days for March in a leap year.
Execution:
  Arrange: None
  Act: Call the month_days function with month=3 and leap_year=True
  Assert: Confirm that the function returns 31
Validation:
  This test is essential for confirming the correct behavior of the function for a common month, ensuring that the function can handle months with 31 days and leap years.

Scenario 3: Verify the number of days in June for a leap year
TestName: test_month_days_june_leap_year
Description: Verify that the function returns 30 days for June in a leap year.
Execution:
  Arrange: None
  Act: Call the month_days function with month=6 and leap_year=True
  Assert: Confirm that the function returns 30
Validation:
  This test is necessary for confirming the correct behavior of the function for a common month, ensuring that the function can handle months with 30 days and leap years.

Scenario 4: Verify the number of days in February for a non-leap year
TestName: test_month_days_february_non_leap_year
Description: Check that the function returns 28 days for February in a non-leap year.
Execution:
  Arrange: None
  Act: Call the month_days function with month=2 and leap_year=False
  Assert: Confirm that the function returns 28
Validation:
  This test is crucial for verifying the correct behavior of the function for February in a non-leap year, ensuring that the function can handle the unique number of days for this month.

Scenario 5: Verify the number of days in February for a leap year
TestName: test_month_days_february_leap_year
Description: Ensure that the function returns 29 days for February in a leap year.
Execution:
  Arrange: None
  Act: Call the month_days function with month=2 and leap_year=True
  Assert: Confirm that the function returns 29
Validation:
  This test is essential for confirming the correct behavior of the function for February in a leap year, ensuring that the function can handle the unique number of days for this month.

Scenario 6: Verify that an exception is raised for an invalid month input
TestName: test_month_days_invalid_month
Description: Confirm that an exception is raised when an invalid month value (not in [1, 12]) is provided.
Execution:
  Arrange: None
  Act: Call the month_days function with month=13 or month=0
  Assert: Confirm that an exception is raised
Validation:
  This test is important for verifying that the function correctly handles invalid input, ensuring that it fails fast and provides clear feedback when incorrect input is provided.

Scenario 7: Verify that an exception is raised for an invalid leap_year input
TestName: test_month_days_invalid_leap_year
Description: Confirm that an exception is raised when an invalid leap_year value (not a boolean) is provided.
Execution:
  Arrange: None
  Act: Call the month_days function with leap_year=1 or leap_year=None
  Assert: Confirm that an exception is raised
Validation:
  This test is important for verifying that the function correctly handles invalid input, ensuring that it fails fast and provides clear feedback when incorrect input is provided.
"""

# ********RoostGPT********
# calculate.py
def is_leap(year):
    if year % 4!= 0:
        return False
    elif year % 100!= 0:
        return True
    elif year % 400!= 0:
        return False
    else:
        return True

def month_days(month, leap_year):
    if month < 1 or month > 12:
        raise ValueError("Invalid month")
    if leap_year not in (True, False):
        raise ValueError("Invalid leap year value")
    months_31 = [1, 3, 5, 7, 8, 10, 12]
    if month in months_31:
        return 31
    elif month == 2:
        return 29 if leap_year else 28
    else:
        return 30

# test_CalculateMonthDays.py
import time
from calendar import isleap
from calculate import month_days, is_leap

def test_month_days_january_non_leap_year():
    assert month_days(1, False) == 31

def test_month_days_march_leap_year():
    assert month_days(3, True) == 31

def test_month_days_june_leap_year():
    assert month_days(6, True) == 30

def test_month_days_february_non_leap_year():
    assert month_days(2, False) == 28

def test_month_days_february_leap_year():
    assert month_days(2, True) == 29

def test_month_days_invalid_month():
    with pytest.raises(ValueError):
        month_days(13, False)
    with pytest.raises(ValueError):
        month_days(0, False)

def test_month_days_invalid_leap_year():
    with pytest.raises(ValueError):
        month_days(1, 1)
    with pytest.raises(ValueError):
        month_days(1, None)
